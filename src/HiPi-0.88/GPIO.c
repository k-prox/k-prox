/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.51 from the
 * contents of GPIO.xs. Do not edit this file, edit GPIO.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

///////////////////////////////////////////////////////////////////////////////////////
// File          GPIO.xs
// Description:  XS module for HiPi::GPIO
// Copyright:    Copyright (c) 2017 Mark Dootson
// License:      This is free software; you can redistribute it and/or modify it under
//               the same terms as the Perl 5 programming language system itself.
//
//               Some of this work is based on pigpio - see
//               https://github.com/joan2937/pigpio
///////////////////////////////////////////////////////////////////////////////////////

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "mylib/include/ppport.h"

#include <sys/mman.h>
#include <stdio.h>

#define GPIO_BASE     0x200000
#define GPIO_LEN      0xB4
#define GPIO_LEN_PI4  0xF4

#define PI_INIT_FAILED -1

#define BANK (gpio>>5)
#define BIT  (1<<(gpio&0x1F))

/* gpio: 0-53 */

#define PI_MIN_GPIO       0
#define PI_MAX_GPIO      53
#define PI_PIN_ERROR     -1
#define PI_EDGE_ERROR     -1

/* user_gpio: 0-31 */

#define PI_MAX_USER_GPIO 31

/* level: 0-1 */

#define PI_OFF   0
#define PI_ON    1

#define PI_CLEAR 0
#define PI_SET   1

#define PI_LOW   0
#define PI_HIGH  1

/* mode: 0-7 */

#define PI_INPUT  0
#define PI_OUTPUT 1
#define PI_ALT0   4
#define PI_ALT1   5
#define PI_ALT2   6
#define PI_ALT3   7
#define PI_ALT4   3
#define PI_ALT5   2
#define PI_MAX_MODE 7

/* pud: 0-2 */

#define PI_PUD_OFF  0
#define PI_PUD_DOWN 1
#define PI_PUD_UP   2
#define PI_PUD_UNSET 0x08

/* locations */

#define GPFSEL0    0

#define GPSET0     7
#define GPSET1     8

#define GPCLR0    10
#define GPCLR1    11

#define GPLEV0    13
#define GPLEV1    14

#define GPEDS0    16
#define GPEDS1    17

#define GPREN0    19
#define GPREN1    20
#define GPFEN0    22
#define GPFEN1    23
#define GPHEN0    25
#define GPHEN1    26
#define GPLEN0    28
#define GPLEN1    29
#define GPAREN0   31
#define GPAREN1   32
#define GPAFEN0   34
#define GPAFEN1   35

#define GPPUD     37
#define GPPUDCLK0 38
#define GPPUDCLK1 39

#define GPPUPPDN0 57
#define GPPUPPDN1 58
#define GPPUPPDN2 59
#define GPPUPPDN3 60

#define RPI_1_BASE 0x20000000
#define RPI_2_BASE 0x3F000000
#define RPI_3_BASE 0x3F000000
#define RPI_4_BASE 0xFE000000


static int fdMem = -1;
static volatile uint32_t * gpio_register = MAP_FAILED;
static volatile uint32_t pi_is_2711    = 0;
static volatile uint32_t alt_gpio_len  = GPIO_LEN;
static volatile uint32_t base_address = 0;

// pre-declares required
static int  do_initialise(void);
static void do_uninitialise(void);
static void send_module_error( char * error );

// init peripherals
static int set_perhipherals(void)
{
    const char *ranges_file = "/proc/device-tree/soc/ranges";
    uint8_t ranges[12];
    FILE *fd;
    
    memset(ranges, 0, sizeof(ranges));

    if ((fd = fopen(ranges_file, "rb")) == NULL)
    {
        return PI_INIT_FAILED;
    }
    else if (fread(ranges, 1, sizeof(ranges), fd) >= 8)
    {
        base_address = (ranges[4] << 24) |
              (ranges[5] << 16) |
              (ranges[6] << 8) |
              (ranges[7] << 0);
        if (!base_address)
            base_address = (ranges[8] << 24) |
                  (ranges[9] << 16) |
                  (ranges[10] << 8) |
                  (ranges[11] << 0);
        if ((ranges[0] != 0x7e) ||
                (ranges[1] != 0x00) ||
                (ranges[2] != 0x00) ||
                (ranges[3] != 0x00) ||
                ((base_address != RPI_1_BASE) && (base_address != RPI_2_BASE) && (base_address != RPI_4_BASE)))
        {
             return PI_INIT_FAILED;
        }
    }
    else
    {
	    return PI_INIT_FAILED;
    }

    fclose(fd);
    
    if( base_address == RPI_4_BASE )
    {
        pi_is_2711 = 1;
        alt_gpio_len = GPIO_LEN_PI4;
    }

    return 0;
}


// map a memory block
static uint32_t *  map_gpiomem(int fd, uint32_t addr, uint32_t len)
{
    return (uint32_t *) mmap(0, len, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED|MAP_LOCKED, fd, addr);
}

// open /dev/gpiomem
static int open_gpiomen(void)
{
    if ((fdMem = open("/dev/gpiomem", O_RDWR | O_SYNC) ) < 0)
    {
        return PI_INIT_FAILED;
    }
    
    return 0;
}

// initialise lib
static int do_initialise(void)
{
    if(set_perhipherals() == PI_INIT_FAILED)
    {
        send_module_error("HiPi::GPIO failed to set peripherals");
        return 0;
    }
    
    if(open_gpiomen() == PI_INIT_FAILED)
    {
        send_module_error("HiPi::GPIO failed to open memory device /dev/gpiomem");
        do_uninitialise();
        return 0;
    }
    
    gpio_register = map_gpiomem(fdMem, GPIO_BASE, alt_gpio_len);

    if (gpio_register == MAP_FAILED)
    {
        send_module_error("HiPi::GPIO failed to map gpio memory block");
        do_uninitialise();
        return 0;
    }
    
    return 1;
}

// uninitialise lib
static void do_uninitialise(void)
{
    if (gpio_register != MAP_FAILED) munmap((void *)gpio_register, alt_gpio_len);
    gpio_register == MAP_FAILED;
    
    if (fdMem != -1)
    {
       close(fdMem);
       fdMem = -1;
    }
}

// delay microseconds
static void delay_microseconds(uint32_t inputmicros)
{
    struct timespec ts, rem;
    int seconds = inputmicros / 1000000;
    int micros  = inputmicros % 1000000;
    
    ts.tv_sec  = seconds;
    ts.tv_nsec = micros * 1000;
 
    while ( clock_nanosleep(CLOCK_REALTIME, 0, &ts, &rem) )
    {
       ts = rem;
    } 
}

// set pud mode

static void do_gpio_set_pud(unsigned gpio, unsigned pud)
{
    
    int shift = (gpio & 0xf) << 1;
    uint32_t bits;
    uint32_t pull;
    
    if( pi_is_2711 ) {
        
        switch (pud)
        {
           case PI_PUD_OFF:  pull = 0; break;
           case PI_PUD_UP:   pull = 1; break;
           case PI_PUD_DOWN: pull = 2; break;
        }
  
        bits = *(gpio_register + GPPUPPDN0 + (gpio>>4));
        bits &= ~(3 << shift);
        bits |= (pull << shift);
        *(gpio_register + GPPUPPDN0 + (gpio>>4)) = bits;
     
    } else {
        *(gpio_register + GPPUD) = pud;
       
        delay_microseconds(20);
     
        *(gpio_register + GPPUDCLK0 + BANK) = BIT;
     
        delay_microseconds(20);
     
        *(gpio_register + GPPUD) = 0;
     
        *(gpio_register + GPPUDCLK0 + BANK) = 0;
    }
   
}

// get pud mode

int do_gpio_get_pud(unsigned gpio)
{
    int retval = PI_PUD_UNSET;   
    if( pi_is_2711 )
    {
        int pull_bits = (*(gpio_register + GPPUPPDN0 + (gpio >> 4)) >> ((gpio & 0xf)<<1)) & 0x3;
        switch (pull_bits)
        {
            case 0: retval = PI_PUD_OFF; break;
            case 1: retval = PI_PUD_UP; break;
            case 2: retval = PI_PUD_DOWN; break;
            default: retval = PI_PUD_UNSET; break;
        } 
    }
    return retval;
}

// set pin mode

static void do_gpio_set_mode(unsigned gpio, unsigned mode)
{
   int reg, shift;
   
   reg   =  gpio/10;
   shift = (gpio%10) * 3;

   gpio_register[reg] = (gpio_register[reg] & ~(7<<shift)) | (mode<<shift);
}

// get pin mode
int do_gpio_get_mode(unsigned gpio)
{
   int reg, shift;
   
   reg   =  gpio/10;
   shift = (gpio%10) * 3;

   return (gpio_register[reg] >> shift) & 7;
}

// read pin value
static int do_gpio_read(unsigned gpio)
{
    if ((*(gpio_register + GPLEV0 + BANK) & BIT) != 0)
    {
        return PI_ON;
    } else {
        return PI_OFF;
    }
}

// write pin value
static void do_gpio_write(unsigned gpio, unsigned level)
{
    if (level == PI_ON) {
        *(gpio_register + GPSET0 + BANK) = BIT;
    } else {
        *(gpio_register + GPCLR0 + BANK) = BIT;
    }
}

// set bits

static void do_gpio_set_bits( uint32_t offset, uint32_t value, uint32_t mask )
{
    uint32_t val = *(gpio_register + offset);
    val = (val & ~mask) | (value & mask);
    *(gpio_register + offset) = val;
}

// edge detection register settings
static void do_gpio_set_egdereg_pin_bit(unsigned gpio, unsigned reg)
{
    
    uint32_t value   = BIT;
    uint32_t mask    = BIT;
    uint32_t offset  = reg + BANK;
    
    do_gpio_set_bits( offset, value, mask );
}

static int do_gpio_get_egdereg_pin_bit(unsigned gpio, unsigned reg)
{
    if ((*(gpio_register + reg + BANK) & BIT) != 0)
    {
        return PI_SET;
    } else {
        return PI_CLEAR;
    }
}

static void do_gpio_clear_edgereg_pin_bit(unsigned gpio, unsigned reg)
{
    
    uint32_t value   = 0;
    uint32_t mask    = BIT;
    uint32_t offset  = reg + BANK;
    do_gpio_set_bits( offset, value, mask );
}

static int do_gpio_get_eds(unsigned gpio)
{
    if ((*(gpio_register + GPEDS0 + BANK) & BIT) != 0)
    {
        return PI_SET;
    } else {
        return PI_CLEAR;
    }
}

static void do_gpio_set_eds(unsigned gpio)
{
    *(gpio_register + GPEDS0 + BANK) = BIT;
}
// send error to module

static void send_module_error( char * error )
{
    dSP;
	ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        EXTEND(SP, 1);
        PUSHs(sv_2mortal(newSVpv(error, 0)));
        PUTBACK;
        call_pv("HiPi::GPIO::error_report", G_DISCARD);
        FREETMPS;
        LEAVE;
}

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif


XS_EUPXS(XS_HiPi__GPIO_xs_initialise_gpio_block); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_initialise_gpio_block)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
    RETVAL = do_initialise();
	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_release_gpio_block); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_release_gpio_block)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
    do_uninitialise();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gpio, level");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	unsigned	level = (unsigned)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else if (level > PI_ON) {
        send_module_error("bad level specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        // if (do_gpio_getmode(gpio) != PI_OUTPUT) do_gpio_setmode(gpio, PI_OUTPUT);
        do_gpio_write( gpio, level );
        RETVAL = (int)level;
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gpio");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        RETVAL = do_gpio_read(gpio);
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_mode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_mode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gpio, mode");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	unsigned	mode = (unsigned)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else if( mode > PI_MAX_MODE ){
        send_module_error("bad mode specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        do_gpio_set_mode( gpio, mode);
        RETVAL = (int)mode;
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_mode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_mode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gpio");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        RETVAL = do_gpio_get_mode( gpio );
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_pud); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_pud)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gpio, pud");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	unsigned	pud = (unsigned)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else if( pud > PI_PUD_UP ){
        send_module_error("bad pud action specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        // set the pud
        do_gpio_set_pud( gpio, pud);
        RETVAL = (int)pud;
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_pud); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_pud)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gpio");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        // get the pud

        RETVAL = do_gpio_get_pud( gpio );
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_peripheral_base_address); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_peripheral_base_address)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	uint32_t	RETVAL;
	dXSTARG;
    RETVAL = base_address;

	XSprePUSH;
	PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_edge_detect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_set_edge_detect)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "gpio, edge, onoff");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	unsigned	edge = (unsigned)SvUV(ST(1))
;
	unsigned	onoff = (unsigned)SvUV(ST(2))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else if( edge != GPREN0 && edge != GPFEN0 && edge != GPHEN0 && edge != GPLEN0 && edge != GPAREN0 && edge != GPAFEN0 ) {
        RETVAL = PI_EDGE_ERROR;
        send_module_error("bad edge type specified");
    } else if( onoff > 1 ){
        send_module_error("bad edge setting specified");
        RETVAL = PI_PIN_ERROR;
    } else if( onoff == 1 ) {
        // set the edge
        do_gpio_set_egdereg_pin_bit( gpio, edge );
        RETVAL = (int)gpio;
    } else {
        do_gpio_clear_edgereg_pin_bit( gpio, edge );
        RETVAL = (int)gpio;
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_edge_detect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_get_edge_detect)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gpio, edge");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	unsigned	edge = (unsigned)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else if( edge != GPREN0 && edge != GPFEN0 && edge != GPHEN0 && edge != GPLEN0 && edge != GPAREN0 && edge != GPAFEN0 ) {
        RETVAL = PI_EDGE_ERROR;
        send_module_error("bad edge type specified");
    } else {
        RETVAL = do_gpio_get_egdereg_pin_bit( gpio, edge );
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_clear_edge_detect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_clear_edge_detect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gpio");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        do_gpio_set_eds( gpio );
        RETVAL = (int)gpio;
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_HiPi__GPIO_xs_gpio_read_edge_detect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_HiPi__GPIO_xs_gpio_read_edge_detect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gpio");
    {
	unsigned	gpio = (unsigned)SvUV(ST(0))
;
	int	RETVAL;
	dXSTARG;
    if (gpio > PI_MAX_GPIO) {
        send_module_error("bad gpio number specified");
        RETVAL = PI_PIN_ERROR;
    } else {
        RETVAL = do_gpio_get_eds( gpio );
    }

	XSprePUSH;
	PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C" {
#endif
XS_EXTERNAL(boot_HiPi__GPIO); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_HiPi__GPIO)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if PERL_VERSION_LE(5, 8, 999) /* PERL_VERSION_LT is 5.33+ */
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("HiPi::GPIO::xs_initialise_gpio_block", XS_HiPi__GPIO_xs_initialise_gpio_block);
        newXS_deffile("HiPi::GPIO::xs_release_gpio_block", XS_HiPi__GPIO_xs_release_gpio_block);
        newXS_deffile("HiPi::GPIO::xs_gpio_write", XS_HiPi__GPIO_xs_gpio_write);
        newXS_deffile("HiPi::GPIO::xs_gpio_read", XS_HiPi__GPIO_xs_gpio_read);
        newXS_deffile("HiPi::GPIO::xs_gpio_set_mode", XS_HiPi__GPIO_xs_gpio_set_mode);
        newXS_deffile("HiPi::GPIO::xs_gpio_get_mode", XS_HiPi__GPIO_xs_gpio_get_mode);
        newXS_deffile("HiPi::GPIO::xs_gpio_set_pud", XS_HiPi__GPIO_xs_gpio_set_pud);
        newXS_deffile("HiPi::GPIO::xs_gpio_get_pud", XS_HiPi__GPIO_xs_gpio_get_pud);
        newXS_deffile("HiPi::GPIO::xs_gpio_get_peripheral_base_address", XS_HiPi__GPIO_xs_gpio_get_peripheral_base_address);
        newXS_deffile("HiPi::GPIO::xs_gpio_set_edge_detect", XS_HiPi__GPIO_xs_gpio_set_edge_detect);
        newXS_deffile("HiPi::GPIO::xs_gpio_get_edge_detect", XS_HiPi__GPIO_xs_gpio_get_edge_detect);
        newXS_deffile("HiPi::GPIO::xs_gpio_clear_edge_detect", XS_HiPi__GPIO_xs_gpio_clear_edge_detect);
        newXS_deffile("HiPi::GPIO::xs_gpio_read_edge_detect", XS_HiPi__GPIO_xs_gpio_read_edge_detect);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

#ifdef __cplusplus
}
#endif
